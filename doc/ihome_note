1.前后端分离
    缺点对于搜索，需要搜索SEO，如何将关键词与网站更紧密将搜索排名提前。
    为了推广，需要将让网络爬虫爬取（网络中搜索引擎爬虫）的页面，进行前后端不分离方式重写。

2.Flask-session
    文档连接：https://pythonhosted.org/Flask-Session/
    在配置类中添加相关参数。

3.日志logging

4.数据库表，根据页面逻辑，搜索条件，空间换时间便捷性 设计表。

5.csrf防护机制
    client --- post/put/delete ---> server

    cookie:                     csrf验证机制：
      csrf_token:xxx            从cookie中获取一个csrf_token,
    body:                       从请求体重获取一个csrf_token的值，
      csrf_token:xxx            如果两个值相同，则检验通过，可以进入到视图函数执行，
                                如果不同，则检验失败，会向前端返回400的错误。
    登录时
    获得server的csrf_token

                POST:
                cookies:user_id=123
                        csrf_token=xxx
                body:to_user=hack
                money:1000
                csrf_token:xxx

6.验证码
    client                                   server                       redis
    编号    ----发起获取图片验证码的请求--->   生成验证码图片，编号
            <---返回验证码图片，编号----      将验证码的真实值和编号存到redis

           ---发起获取短信验证码请求---->      验证图片验证码的正确性
                携带参数：                   若正确，发送短信验证码
                    用户填写的图片验证码
                    图片验证码的编号

    2.编号
        时间戳
        uuid 全局唯一标识符

7.
    1.需求分析
    2.编写代码
    3.编写单元测试
    4.自测
    5.编写接口文档
    6.检测代码

8.云通信
    1.容联云通信 申请短信服务
    2.单例模式
        class CCP(object):
            """自己封装的发送短信的辅助类"""
            # 用来保存对象的类属性
            instance = None

            def __new__(cls):
                # 判断CCP类有没有已经创建好的对象，如果没有，创建一个对象，并且保存
                # 如果有，则将保存的对象直接返回
                if cls.instance is None:
                    obj = super(CCP, cls).__new__(cls)

                    # 初始化REST SDK
                    obj.rest = REST(serverIP, serverPort, softVersion)
                    obj.rest.setAccount(accountSid, accountToken)
                    obj.rest.setAppId(appId)

                    cls.instance = obj

                return cls.instance

            def send_template_sms(self, to, datas, temp_id):
                """"""
                result = self.rest.sendTemplateSMS(to, datas, temp_id)
                # for k, v in result.iteritems():
                #
                #     if k == 'templateSMS':
                #         for k, s in v.iteritems():
                #             print '%s:%s' % (k, s)
                #     else:
                #         print '%s:%s' % (k, v)
                # smsMessageSid:ff75e0f84f05445ba08efdd0787ad7d0
                # dateCreated:20171125124726
                # statusCode:000000
                status_code = result.get("statusCode")
                if status_code == "000000":
                    # 表示发送短信成功
                    return 0
                else:
                    # 发送失败
                    return -1


        if __name__ == '__main__':
            ccp = CCP()
            ret = ccp.send_template_sms("18516952650", ["1234", "5"], 1)
            print(ret)

